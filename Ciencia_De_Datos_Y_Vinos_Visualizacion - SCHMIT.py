# -*- coding: utf-8 -*-
"""Analisis de Vinos - Visualizacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zcd0ODHpZS6Rrjf8z_Q7w2G2x39Z4qfm
"""



import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from collections import Counter
from wordcloud import WordCloud
import nltk
from nltk.corpus import stopwords
import string
import re

from google.colab import files
uploaded = files.upload()  # Selecccionar el archivo winemag-data-130k-v8.xlsx

## A continuacion se incluye como comentario el codigo con el cual se llego a la limpieza del documento original winemag-data-130k-v2 en el Trabajo Practico 2

'''print("# CODIGO 1 : Subir el archivo winemag-data-130k-v3, el cual ha sido previamente arreglado de la siguiente manera:\n Se agrego nombre a la primera columna: Review \n Se eliminaron las columnas 'unnamed'\ Se concatenaron las asociadas con 'description' en una sola columna \n Se arreglarong las 3 filas que presentabas datos distribuidos en dos o mas registros \n Esta parte del codigo corrobora que el campo Review sea un campo unico y que sea secuencial")

# Cargar el archivo que ha sido manualmente corregido para que las lineas que estaban separadas , se ubiquen correctamente
file_path = 'winemag-data-130k-v3.xlsx'
df = pd.read_excel(file_path)

# Asegurarse de que la columna Review es de tipo numérico
df['Review'] = pd.to_numeric(df['Review'], errors='coerce')

# Revisar duplicados en la columna review
duplicates = df['Review'].duplicated().any()  # Verifica si hay duplicados

if duplicates:
    print("Hay números de reseña duplicados.")
else:
    print("No hay números de reseña duplicados.")

# Revisar secuencialidad
# Obtener los números de reseña únicos y ordenarlos
unique_reviews = df['Review'].dropna().unique()  # Eliminar NaN y obtener valores únicos
unique_reviews.sort()

# Comprobar si hay números faltantes en la secuencia
missing_reviews = [i for i in range(int(unique_reviews.min()), int(unique_reviews.max() + 1)) if i not in unique_reviews]

if missing_reviews:
    print(f"Números de reseña faltantes: {missing_reviews}")
else:
    print("Todos los números de reseña están en orden secuencial.")

print("\n # CODIGO 2 : Utilizando el archivo winemag-data-130k-v3, se procedera a explorar cada variable en profundidad y a tratar datos faltantes y atipicos \n")

# ===========================================
#CODIGO 2 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable 'country'

# ===========================================
# Listas para almacenar los países completados por cada método
# ===========================================
filled_with_winery = []
filled_with_designation = []
filled_with_taster = []

# ===========================================
# ** Mensaje de inicio **
# ===========================================
start_message = (
    "El siguiente trabajo de limpieza utilizará el archivo **winemag-data-130k-v3.xlsx**.\n"
    "Este archivo ya ha sido manualmente arreglado:\n"
    "- Se ha agregado el nombre a la primer columna **'Review'** para denotar el número de reseña que identifica la entrada.\n"
    "- Se han identificado las líneas donde las reseñas se habían distribuido en dos o más líneas y se han arreglado.\n"
)

Limpieza_Country = (
    "En este set de datos hay varias columnas con datos faltantes y outliers.\n"
    "La metodología elegida será la de arreglar columna por columna usando diversas estrategias:\n"
    "Para la variable **Country** se utilizará la información existente con respecto a bodegas y designaciones para completar países faltantes."
    "Cuando la informacion referida a bodegas y designaciones sea insuficiente, se procedera a completar el campo **Country** con el pais mayormente asociado al degustador de la reseña\n"
)

print(start_message)
print(Limpieza_Country)

# ===========================================
# ** 0. Cargar los datos **
# ===========================================
df = pd.read_excel('winemag-data-130k-v3.xlsx')

# Copia del DataFrame original para comparaciones más adelante
df_copy = df.copy()

# ===========================================
# ** 1. Mostrar filas donde 'country' es NaN **
# ===========================================
missing_rows = df[df['country'].isna()][['Review', 'country', 'winery', 'designation', 'taster_name']]
print(f"\n*** Filas donde 'Country' es un valor nulo (Review, Country, Winery, Designation, Taster Name): {missing_rows.shape[0]} ***")

# ===========================================
# ** 2. Rellenar 'country' usando 'winery' **
# ===========================================
# Creamos un diccionario para buscar el país basado en el nombre de la bodega
winery_country_dict = df.dropna(subset=['country']).drop_duplicates(subset=['winery']).set_index('winery')['country'].to_dict()

def fill_country_with_winery(row):
    if pd.isna(row['country']):  # Solo rellenar si country está vacío
        winery_value = row['winery']
        country_value = winery_country_dict.get(winery_value, np.nan)
        if not pd.isna(country_value):
            filled_with_winery.append(country_value)  # Agregar a la lista de completados
        return country_value
    return row['country']

# Creamos una columna que nos diga si el país fue completado con winery
df['country_before_winery'] = df['country'].copy()
df['country'] = df.apply(fill_country_with_winery, axis=1)
df['filled_with_winery'] = np.where(df['country_before_winery'].isna() & df['country'].notna(), True, False)

# ===========================================
# ** 3. Rellenar 'country' usando 'designation' **
# ===========================================
# Creamos un diccionario para buscar el país basado en la designación
designation_country_dict = df.dropna(subset=['country']).drop_duplicates(subset=['designation']).set_index('designation')['country'].to_dict()

def fill_country_with_designation(row):
    if pd.isna(row['country']):  # Solo rellenar si country está vacío
        designation_value = row['designation']
        country_value = designation_country_dict.get(designation_value, np.nan)
        if not pd.isna(country_value):
            filled_with_designation.append(country_value)  # Agregar a la lista de completados
        return country_value
    return row['country']

# Creamos una columna que nos diga si el país fue completado con designation
df['country_before_designation'] = df['country'].copy()
df['country'] = df.apply(fill_country_with_designation, axis=1)
df['filled_with_designation'] = np.where(df['country_before_designation'].isna() & df['country'].notna(), True, False)

# ===========================================
# ** 4. Mostrar filas corregidas usando winery y designation **
# ===========================================
corrected_rows = df[df['country'].notna() & df['country_before_winery'].isna()][['Review', 'country', 'winery', 'designation']]
print(f"\n*** Filas donde 'Country' fue corregido (Review, Country, Winery, Designation): {corrected_rows.shape[0]} ***")

# ===========================================
# ** 5. Rellenar 'country' usando 'taster_name' **
# ===========================================
# Crear un diccionario que almacene el país más común para cada taster
country_by_taster = df.groupby('taster_name')['country'].agg(lambda x: x.mode()[0] if not x.mode().empty else np.nan).to_dict()

def fill_country_with_taster(row):
    if pd.isna(row['country']):  # Solo rellenar si country está vacío
        taster_name = row['taster_name']
        country_value = country_by_taster.get(taster_name, np.nan)
        if not pd.isna(country_value):
            filled_with_taster.append(country_value)  # Agregar a la lista de completados
            return country_value
        else:
            print(f"No se encontró país para el catador: {taster_name}")
    return row['country']

# Creamos una columna que nos diga si el país fue completado con taster_name
df['country_before_taster'] = df['country'].copy()
df['country'] = df.apply(fill_country_with_taster, axis=1)
df['filled_with_taster'] = np.where(df['country_before_taster'].isna() & df['country'].notna(), True, False)

# ===========================================
# ** 6. Mostrar cuántos países fueron completados por cada método **
# ===========================================
print(f"\nPaíses completados usando 'winery': {len(filled_with_winery)}")
print(f"Países completados usando 'designation': {len(filled_with_designation)}")
print(f"Países completados usando 'taster_name': {len(filled_with_taster)}")

# ===========================================
# ** 7. Mostrar filas que aún están faltando **
# ===========================================
missing_rows_after_taster = df[df['country'].isna()][['Review', 'country', 'winery', 'designation', 'taster_name']]
print(f"\n*** Filas aún con 'Country' faltante después de la limpieza (Review, Country, Winery, Designation, Taster Name): {missing_rows_after_taster.shape[0]} ***\n")

# ===========================================
# ** 8. Mostrar los registros completos con país rellenado por cualquier método **
# ===========================================
completed_countries = df[
    (df['country'].notna()) &  # El país ha sido completado
    (
        df['country_before_winery'].isna() |  # Completado por 'winery'
        df['country_before_designation'].isna() |  # Completado por 'designation'
        df['country_before_taster'].isna()  # Completado por 'taster_name'
    )
][['Review', 'country', 'winery', 'designation', 'taster_name']]

# Mostrar el total de registros completados y los datos correspondientes
print(f"\n*** Total de registros completados: {completed_countries.shape[0]} ***")

# Guardar el DataFrame modificado en un nuevo archivo Excel llamado winemag-data-130k-v4.xlsx
df.to_excel('winemag-data-130k-v4.xlsx', index=False)

print("\n*** Los datos han sido guardados en 'winemag-data-130k-v4.xlsx' ***")

# ===========================================
#CODIGO 3 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable "description"
print("\n # CODIGO 3 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable 'description' ")

# ===========================================
# ** Cargar los datos **
# ===========================================
df_v4 = pd.read_excel('winemag-data-130k-v4.xlsx')


# ===========================================
# ** 1. Verificar valores nulos en la columna ' description '
# ===========================================
# Verificar cuántos valores nulos hay en 'description'
missing_descriptions = df_v4['description'].isna().sum()
print(f"\nNúmero de descripciones faltantes (NaN): {missing_descriptions}")


# ===========================================
# ** Verificar descripciones duplicadas **
# ===========================================
duplicate_descriptions = df_v4[df_v4.duplicated(subset='description', keep=False)]
print(f"\nNúmero de descripciones duplicadas: {duplicate_descriptions.shape[0]}")

# ===========================================
# ** Buscar caracteres inusuales **
# ===========================================
unusual_descriptions = df_v4[df_v4['description'].str.contains(r'[^a-zA-Z\s]', regex=True)]
print(f"\nNúmero de descripciones con caracteres inusuales: {unusual_descriptions.shape[0]}")


# ===========================================
# ** Verificar si hay duplicados considerando 'description', 'title', 'taster_name', y 'winery' **
# ===========================================

duplicate_reviews = df_v4[df_v4.duplicated(subset=['description', 'title', 'taster_name', 'winery'], keep=False)]

print(f"\nNúmero de reseñas duplicadas (description + title + taster_name + winery): {duplicate_reviews.shape[0]}")


# ===========================================
# ** Eliminar reseñas duplicadas, considerando 'description', 'title', 'taster_name', y 'winery', manteniendo solo la primera aparición **
# ===========================================
df_v4_clean = df_v4.drop_duplicates(subset=['description', 'title', 'taster_name', 'winery'], keep='first')

# Guardar el archivo limpio en un nuevo archivo llamado 'winemag-data-130k-v5.xlsx'
df_v4_clean.to_excel('winemag-data-130k-v5.xlsx', index=False)

# Mostrar cuántas reseñas quedan en el nuevo archivo después de la limpieza
print(f"\nNúmero de filas después de eliminar duplicados: {df_v4_clean.shape[0]}")

# ===========================================
# CODIGO 4 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable "Designations"
print("\n # CODIGO 4 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable 'Designations'")

# ===========================================
# ** Cargar los datos **
# ===========================================
df_v4 = pd.read_excel('winemag-data-130k-v5.xlsx')

# ===========================================
# ** 1. Verificar valores nulos en la columna 'designation' **
# ===========================================
# Verificar cuántos valores nulos hay en 'designation'
missing_designations = df_v4['designation'].isna().sum()  # Asegúrate de que el nombre sea correcto
print(f"\nNúmero de designaciones faltantes (NaN): {missing_designations}")

# ===========================================
# ** 2. Rellenar valores nulos en la columna 'designation' con 'Desconocido' **
# ===========================================
df_v4['designation'] = df_v4['designation'].fillna('Desconocido')

# ===========================================
# ** 3. Verificar la distribución después de rellenar los nulos **
# ===========================================
missing_designations_after = df_v4['designation'].isna().sum()  # Comprobar nuevamente los NaN
print(f"\nNúmero de designaciones faltantes (NaN) después de la limpieza: {missing_designations_after}")

# ===========================================
# ** 4. Guardar el DataFrame modificado como un nuevo archivo Excel **
# ===========================================
df_v4.to_excel('winemag-data-130k-v6.xlsx', index=False)  # Guarda sin el índice
print("\nEl archivo se ha guardado como 'winemag-data-130k-v6.xlsx'.")

print("\n # CODIGO 5 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable 'Price'")
# ===========================================
# CODIGO 5 - Limpieza y tratamiendo de datos faltantes y atipicos : Variable "Price"

# ===========================================
# ** Cargar los datos **
# ===========================================
df_v4 = pd.read_excel('winemag-data-130k-v6.xlsx')

# ===========================================
# ** 1. Verificar valores nulos en la columna 'price' **
# ===========================================
# Verificar cuántos valores nulos hay en 'price'
missing_price = df_v4['price'].isna().sum()
print(f"\nNúmero de reseñas con precios faltantes (NaN): {missing_price}")

# ===========================================
# ** 2. Calcular precios promedios en base a reseñas de vinos similares utilizando otras reseñas con similar puntaje, país y viñedo **
# ===========================================
average_price = df_v4.groupby(['points', 'country', 'winery'])['price'].mean().reset_index()
average_price.rename(columns={'price': 'average_price'}, inplace=True)
df_v4 = df_v4.merge(average_price, on=['points', 'country', 'winery'], how='left')
df_v4['price'] = df_v4['price'].fillna(df_v4['average_price'])
df_v4.drop(columns=['average_price'], inplace=True)

# ===========================================
# ** 3. Verificar si todos los precios faltantes han sido rellenados **
# ===========================================
missing_price_after = df_v4['price'].isna().sum()
if missing_price_after == 0:
    print("\nTodos los precios faltantes han sido rellenados.")
else:
    print(f"\nAún quedan {missing_price_after} precios faltantes.")

# ===========================================
# ** 4. Calcular precios promedios en base a reseñas de vinos similares utilizando otras reseñas con similar variety **
# ===========================================
if 'variety' in df_v4.columns:
    # Calcular el precio promedio por variety
    average_price_variety = df_v4.groupby('variety')['price'].mean().reset_index()

    # Unir el promedio de precios al DataFrame original
    df_v4 = df_v4.merge(average_price_variety, on='variety', how='left', suffixes=('', '_variety_avg'))

    # Rellenar precios faltantes con el promedio por variety
    df_v4['price'] = df_v4['price'].fillna(df_v4['price_variety_avg'])

    # Eliminar la columna de precios promedio por variety
    df_v4.drop(columns=['price_variety_avg'], inplace=True)

    # Verificar si todos los precios faltantes han sido rellenados
    missing_price_after_variety = df_v4['price'].isna().sum()
    if missing_price_after_variety == 0:
        print("\nTodos los precios faltantes han sido rellenados utilizando variety.")
    else:
        print(f"\nAún quedan {missing_price_after_variety} precios faltantes después de utilizar variety.")

else:
    print("La columna 'variety' no se encuentra en el DataFrame.")

# ===========================================
# ** 5. Calcular precios promedios en base a reseñas de vinos similares utilizando el promedio por país **
# ===========================================
# Calcular el precio promedio por país
average_price_country = df_v4.groupby('country')['price'].mean().reset_index()
average_price_country.rename(columns={'price': 'average_price_country'}, inplace=True)

# Unir el promedio de precios por país al DataFrame
df_v4 = df_v4.merge(average_price_country, on='country', how='left')
df_v4['price'] = df_v4['price'].fillna(df_v4['average_price_country'])

# Eliminar la columna de precios promedio por país
df_v4.drop(columns=['average_price_country'], inplace=True)

# Verificar si todos los precios faltantes han sido rellenados después del promedio por país
missing_price_after_country = df_v4['price'].isna().sum()
if missing_price_after_country == 0:
    print("\nTodos los precios faltantes han sido rellenados utilizando el método por país.")
else:
    print(f"\nAún quedan {missing_price_after_country} precios faltantes después de rellenar por país.")

# ===========================================
# ** 6. Guardar el DataFrame modificado como un nuevo archivo Excel **
# ===========================================
df_v4.to_excel('winemag-data-130k-v7.xlsx', index=False)

print("\n # CODIGO 6 - Limpieza y tratamiendo de datos faltantes y atipicos : Variables 'province', 'region_1', 'region_2', 'taster_name', 'taster_twitter_handle', 'title', 'variety', 'winery'")
# ===========================================
# CODIGO 6 - Limpieza y tratamiendo de datos faltantes y atipicos : Variables 'province', 'region_1', 'region_2', 'taster_name', 'taster_twitter_handle', 'title', 'variety', 'winery'

# ===========================================
# ** Cargar los datos **
# ===========================================
df_v4 = pd.read_excel('winemag-data-130k-v7.xlsx')

# ===========================================
# ** Verificar valores nulos en columnas 'province', 'region_1', 'region_2', 'taster_name', 'taster_twitter_handle', 'title', 'variety', 'winery' **
# ===========================================
columnas_especificas = ['province', 'region_1', 'region_2', 'taster_name', 'taster_twitter_handle', 'title', 'variety', 'winery']

nulos_por_columna_especificas = df_v4[columnas_especificas].isna().sum()

# Mostrar la cantidad de valores nulos por columna en las columnas específicas
print("\nCantidad de valores nulos por columna en las columnas específicas:")
print(nulos_por_columna_especificas)

# ===========================================
# ** Tratamiento de valores nulos en columnas específicas **
# ===========================================

# Tratamiento de valores nulos
# ===========================================
df_v4['province'] = df_v4['province'].fillna('Desconocido')
df_v4['region_1'] = df_v4['region_1'].fillna('Desconocido')
df_v4['region_2'] = df_v4['region_2'].fillna('Desconocido')
df_v4['taster_name'] = df_v4['taster_name'].fillna('Desconocido')
df_v4['taster_twitter_handle'] = df_v4['taster_twitter_handle'].fillna('Desconocido')

# Para 'variety', puedes decidir mantener el valor nulo o llenarlo, ya que solo hay uno
df_v4['variety'] = df_v4['variety'].fillna('Desconocido')  # Si decides llenarlo, aquí se hace


# ===========================================
# ** Verificar si todos los valores nulos han sido rellenados **
# ===========================================
nulos_por_columna_tratadas = df_v4[columnas_especificas].isna().sum()

# Mostrar la cantidad de valores nulos por columna después del tratamiento
print("\nCantidad de valores nulos por columna después del tratamiento:")
print(nulos_por_columna_tratadas)

# ===========================================
# ** Guardar el DataFrame modificado como un nuevo archivo Excel **
# ===========================================
df_v4.to_excel('winemag-data-130k-v8.xlsx', index=False)

print("\n # CODIGO 7 - Exploración de datos en el DataFrame V8 - Archivo Limpio")
# ===========================================
# CODIGO 7 - Exploración de datos en el DataFrame V8 - Archivo Limpio
# ===========================================

# ===========================================
# ** 1. Resumen de las columnas numéricas **
# ===========================================
print("\nResumen de las columnas numéricas:")
print(df_v8.describe())

'''
sns.set(style="whitegrid") # Configuración de estilo para los gráficos

# ===========================================
# ** Cargar los datos **
# ===========================================
df_v8 = pd.read_excel('winemag-data-130k-v8.xlsx')

# Limpiar la columna 'winery' eliminando caracteres no deseados
df_v8['winery'] = df_v8['winery'].apply(lambda x: re.sub(r'[^A-Za-z0-9\s]', '', str(x)))

# ===========================================
# CODIGO 8 - Visualizaciones
# ===========================================
print("\nVISUALIZACIONES: \n")

# ===========================================
# ** 0. Visualizar la distribución de las 10 designaciones más populares
# ===========================================
print("\n 0. Visualizar la distribución de las 10 designaciones más populares  \n")
designation_counts = df_v8['designation'].value_counts().head(10)  # Obtener solo las 10 más populares
designation_counts.plot(kind='bar')
plt.title('Distribución de las 10 Designaciones Más Populares')
plt.xlabel('Designación')
plt.ylabel('Frecuencia')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 1. Visualizar distribución de precios
# ===========================================
print("\n 1.1 Visualizar distribución de precios \n")
plt.figure(figsize=(10, 6))
sns.histplot(df_v8['price'], bins=30, kde=True)
plt.xlim(0, 400)  # Limitar el eje x a un valor máximo de $400
plt.title('Distribución de Precios de Vinos')
plt.xlabel('Precio')
plt.ylabel('Frecuencia')
plt.show()

# Calcular estadísticas de precios
precio_promedio = df_v8['price'].mean()
precio_maximo = df_v8['price'].max()
precio_minimo = df_v8['price'].min()

print("\n 1. Detalle de distribución de precios \n")
# Mostrar resultados
print(f"Precio promedio: ${precio_promedio:.2f}")
print(f"Precio máximo: ${precio_maximo:.2f}")
print(f"Precio mínimo: ${precio_minimo:.2f}")

# Crear bins (intervalos) para agrupar precios
bins = [0, 20, 50, 100, 200, 500, 1000, df_v8['price'].max()]  # Puedes ajustar estos valores según los datos
labels = ['0-20', '21-50', '51-100', '101-200', '201-500', '501-1000', '1001+']

# Crear una nueva columna con las categorías de precios
df_v8['price_range'] = pd.cut(df_v8['price'], bins=bins, labels=labels, right=False)

# Contar vinos en cada rango de precios
price_distribution = df_v8['price_range'].value_counts().sort_index()

# Visualización: Gráfico de barras para la distribución de precios
print("\n 1.2 Distribución de Vinos por Rango de Precios \n")
plt.figure(figsize=(10, 6))
sns.barplot(x=price_distribution.index, y=price_distribution.values, palette='viridis')
plt.title('Distribución de Vinos por Rango de Precios', fontsize=16)
plt.xlabel('Rango de Precio (USD)', fontsize=14)
plt.ylabel('Cantidad de Vinos', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()


# ===========================================
# ** 2. Visualizar distribución de puntos **
# ===========================================
print("\n 2. Visualizar distribución de puntos \n")
plt.figure(figsize=(10, 6))
sns.histplot(df_v8['points'], bins=30, kde=True)
plt.title('Distribución de Puntos de Vinos')
plt.xlabel('Puntos')
plt.ylabel('Frecuencia')
plt.show()

# ===========================================
# ** 3. Gráfico de barras para la variable 'variety' **
# ===========================================
print("\n 3. Gráfico de barras para la variable 'variety' \n")
plt.figure(figsize=(12, 6))
top_varieties = df_v8['variety'].value_counts().nlargest(10)
sns.barplot(x=top_varieties.index, y=top_varieties.values, palette='viridis')
plt.title('Top 10 Variedades de Vino')
plt.xlabel('Variedad')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 4. Gráfico de barras para la variable 'winery' **
# ===========================================
print("\n 4. Gráfico de barras para la variable 'winery' \n")
plt.figure(figsize=(12, 6))
top_wineries = df_v8['winery'].value_counts().nlargest(10)
sns.barplot(x=top_wineries.index, y=top_wineries.values, palette='plasma')
plt.title('Top 10 Viñedos')
plt.xlabel('Viñedo')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 5. Gráfico de barras para la variable 'country' **
# ===========================================
print("\n 5. Gráfico de barras para la variable 'country' \n")
plt.figure(figsize=(12, 6))
top_countries = df_v8['country'].value_counts().nlargest(10)
sns.barplot(x=top_countries.index, y=top_countries.values, palette='mako')
plt.title('Top 10 Países de Vino')
plt.xlabel('País')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 6. Gráfico de barras para la variable 'province' **
# ===========================================
print("\n 6. Gráfico de barras para la variable 'province' \n")
plt.figure(figsize=(12, 6))
top_provinces = df_v8['province'].value_counts().nlargest(10)
sns.barplot(x=top_provinces.index, y=top_provinces.values, palette='crest')
plt.title('Top 10 Provincias de Vino')
plt.xlabel('Provincia')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 7. Gráfico de barras para la variable 'region_1' **
# ===========================================
print("\n 7. Gráfico de barras para la variable 'region_1' \n")
plt.figure(figsize=(12, 6))
top_regions = df_v8['region_1'].value_counts().nlargest(10)
sns.barplot(x=top_regions.index, y=top_regions.values, palette='rocket')
plt.title('Top 10 Regiones (Region_1) de Vino')
plt.xlabel('Región')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 8. Gráfico de barras para la variable 'taster_name' **
# ===========================================
print("\n 8. Gráfico de barras para la variable 'taster_name' \n")
plt.figure(figsize=(12, 6))
top_tasters = df_v8['taster_name'].value_counts().nlargest(10)
sns.barplot(x=top_tasters.index, y=top_tasters.values, palette='cubehelix')
plt.title('Top 10 Catadores')
plt.xlabel('Catador')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

# ===========================================
# ** 9. Gráfico de barras para la variable 'taster_twitter_handle' **
# ===========================================
print("\n 9. Gráfico de barras para la variable 'taster_twitter_handle' \n")
plt.figure(figsize=(12, 6))
top_twitter_handles = df_v8['taster_twitter_handle'].value_counts().nlargest(10)
sns.barplot(x=top_twitter_handles.index, y=top_twitter_handles.values, palette='flare')
plt.title('Top 10 Handles de Twitter de Catadores')
plt.xlabel('Handle de Twitter')
plt.ylabel('Cantidad de Reseñas')
plt.xticks(rotation=45)
plt.show()

print("\n VISUALIZACIONES AVANZADAS \n")

# ===========================================
# ** 10. ¿Qué bodegas consistentemente producen vinos altamente calificados? **
# ===========================================

# Calcula el promedio de puntuaciones por bodega
winery_avg_scores = df_v8.groupby('winery')['points'].mean()

# Filtrar bodegas con puntuaciones promedio entre 80 y 100
winery_avg_scores_filtered = winery_avg_scores[(winery_avg_scores >= 80) & (winery_avg_scores <= 100)].sort_values(ascending=False).head(10)

print("\n 10. ¿Qué bodegas consistentemente producen vinos altamente calificados? \n")

# Visualizar las bodegas con las puntuaciones promedio más altas en el rango de 80 a 100
plt.figure(figsize=(12, 6))
sns.barplot(x=winery_avg_scores_filtered.index, y=winery_avg_scores_filtered.values, palette='viridis')
plt.title('Top 10 Bodegas con Puntuación Promedio Entre 80 y 100')
plt.xlabel('Bodega')
plt.ylabel('Puntuación Promedio')
plt.xticks(rotation=45)

# Ajustar el límite del eje y para que se enfoque entre 80 y 100
plt.ylim(80, 100)

plt.show()

# ===========================================
# ** 10.1 ¿En qué paises se encuentran las bodegas que consistentemente producen vinos altamente calificados? **
# ===========================================

# Obtener los países de estas bodegas
top_wineries = df_v8[df_v8['winery'].isin(winery_avg_scores_filtered.index)]

# Agrupar por país y contar cuántas bodegas de alta puntuación hay por país
country_winery_count = top_wineries.groupby('country')['winery'].nunique().sort_values(ascending=False)

print("\n 10.1 ¿En qué paises se encuentran las bodegas que consistentemente producen vinos altamente calificados? \n")

# Visualizar cuántos países producen estos vinos altamente calificados
plt.figure(figsize=(12, 6))
sns.barplot(x=country_winery_count.index, y=country_winery_count.values, palette='viridis')
plt.title('Número de Países que Producen Vinos Altamente Calificados (Puntuación Promedio Entre 80 y 100)')
plt.xlabel('País')
plt.ylabel('Número de Bodegas')
plt.xticks(rotation=45)

plt.show()

# Mostrar el número de países que producen vinos altamente calificados
num_countries = len(country_winery_count)
print(f"\n Número de países que producen vinos altamente calificados: {num_countries}")

# ===========================================
# ** 10.2 ¿Cuál es el precio promedio de los vinos de las 10 bodegas con puntuaciones más altas (entre 80 y 100)? **
# ===========================================

# Filtrar bodegas con puntuaciones promedio entre 80 y 100 (ya calculado previamente)
winery_avg_scores_filtered = winery_avg_scores[(winery_avg_scores >= 80) & (winery_avg_scores <= 100)].sort_values(ascending=False).head(10)

# Obtener los vinos de estas bodegas altamente calificadas
top_wineries_vines = df_v8[df_v8['winery'].isin(winery_avg_scores_filtered.index)]

# Calcular el precio promedio de los vinos de estas bodegas
average_price_top_wineries = top_wineries_vines['price'].mean()

print("\n 10.2 ¿Cuál es el precio promedio de los vinos de las 10 bodegas con puntuaciones más altas (entre 80 y 100)? \n")

# Imprimir el precio promedio
print(f"El precio promedio de los vinos de las 10 bodegas con puntuación mas alta es: ${average_price_top_wineries:.2f}")

# ===========================================
# Visualización del precio promedio de los vinos de las 10 bodegas con puntuaciones más altas (entre 80 y 100)
# ===========================================

# Calcular el precio promedio por bodega para las bodegas con puntuación en el rango de 80 a 100
winery_price_avg_top_wineries = top_wineries_vines.groupby('winery')['price'].mean().sort_values(ascending=False)

# Visualizar los precios promedio de los vinos de las 10 bodegas con puntuaciones más altas
plt.figure(figsize=(12, 6))
sns.barplot(x=winery_price_avg_top_wineries.index, y=winery_price_avg_top_wineries.values, palette='viridis')
plt.title('Precio Promedio de los Vinos de las 10 Bodegas con Puntuación mas alta')
plt.xlabel('Bodega')
plt.ylabel('Precio Promedio ($)')
plt.xticks(rotation=45)

plt.show()

# ===========================================
# ** 10.3 ¿Cuáles son las 10 bodegas con puntuaciones más bajas entre 80 y 100? **
# ===========================================

# Filtrar bodegas con puntuaciones promedio entre 80 y 100
winery_avg_scores_filtered = winery_avg_scores[(winery_avg_scores >= 80) & (winery_avg_scores <= 100)]

# Obtener las 10 bodegas con las puntuaciones más bajas
winery_avg_scores_lowest = winery_avg_scores_filtered.tail(10)  # Las últimas 10 bodegas en el rango

print("\n 10.3 ¿Cuáles son las 10 bodegas con puntuaciones más bajas entre 80 y 100? \n")

# Visualizar las bodegas con las puntuaciones promedio más bajas
plt.figure(figsize=(12, 6))
sns.barplot(x=winery_avg_scores_lowest.index, y=winery_avg_scores_lowest.values, palette='viridis')
plt.title('Top 10 Bodegas con Puntuación Promedio Más Baja (Entre 80 y 100)')
plt.xlabel('Bodega')
plt.ylabel('Puntuación Promedio')
plt.xticks(rotation=45)

# Ajustar el límite del eje y para que se enfoque entre 80 y 100
plt.ylim(80, 100)
plt.show()

# ===========================================
# ** 10.4 ¿En qué países se encuentran las bodegas con las puntuaciones más bajas? **
# ===========================================

# Obtener los países de estas bodegas con puntuaciones más bajas
top_wineries_lowest = df_v8[df_v8['winery'].isin(winery_avg_scores_lowest.index)]

# Agrupar por país y contar cuántas bodegas de baja puntuación hay por país
country_winery_count_lowest = top_wineries_lowest.groupby('country')['winery'].nunique().sort_values(ascending=False)

print("\n 10.4 ¿En qué países se encuentran las bodegas con las puntuaciones más bajas? \n")

# Visualizar cuántos países producen estos vinos con puntuaciones más bajas
plt.figure(figsize=(12, 6))
sns.barplot(x=country_winery_count_lowest.index, y=country_winery_count_lowest.values, palette='viridis')
plt.title('Número de Países que Producen Vinos con Puntuación Más Baja (Entre 80 y 100)')
plt.xlabel('País')
plt.ylabel('Número de Bodegas')
plt.xticks(rotation=45)
plt.show()

# Mostrar el número de países que producen vinos con puntuaciones más bajas
num_countries_lowest = len(country_winery_count_lowest)
print(f"\n Número de países que producen vinos con puntuaciones más bajas: {num_countries_lowest}")

# ===========================================
# ** 10.5 ¿Cuál es el precio promedio de los vinos de las bodegas con puntuaciones más bajas? **
# ===========================================

# Obtener los vinos de estas bodegas con puntuaciones más bajas
top_wineries_vines_lowest = df_v8[df_v8['winery'].isin(winery_avg_scores_lowest.index)]

# Calcular el precio promedio de los vinos de estas bodegas
average_price_lowest_wineries = top_wineries_vines_lowest['price'].mean()

print("\n 10.5 ¿Cuál es el precio promedio de los vinos de las bodegas con puntuaciones más bajas? \n")

# Imprimir el precio promedio
print(f"El precio promedio de los vinos de las 10 bodegas con puntuación más baja entre 80 y 100 es: ${average_price_lowest_wineries:.2f}")

# ===========================================
# Visualización del precio promedio de los vinos de las 10 bodegas con puntuaciones más bajas (entre 80 y 100)
# ===========================================

# Calcular el precio promedio por bodega para las bodegas con puntuación en el rango de 80 a 100
winery_price_avg_lowest_wineries = top_wineries_vines_lowest.groupby('winery')['price'].mean().sort_values(ascending=False)

# Visualizar los precios promedio de los vinos de las 10 bodegas con puntuaciones más bajas
plt.figure(figsize=(12, 6))
sns.barplot(x=winery_price_avg_lowest_wineries.index, y=winery_price_avg_lowest_wineries.values, palette='viridis')
plt.title('Precio Promedio de los Vinos de las 10 Bodegas con Puntuación Más Baja (Entre 80 y 100)')
plt.xlabel('Bodega')
plt.ylabel('Precio Promedio ($)')
plt.xticks(rotation=45)

plt.show()

# ===========================================
# ** 10.6 Correlacion entre Precios y Puntuaciones Promedio por pais, por variedad de uva y segmento de mercado **
# ===========================================
print("\n 10.6 Correlacion entre Precios y Puntuaciones Promedio por pais, por variedad de uva y segmento de mercado \n")

# Gráfico de precios y puntuaciones promedio por país
country_avg_score_price = df_v8.groupby('country').agg({'points': 'mean', 'price': 'mean'}).sort_values(by='price', ascending=False)

plt.figure(figsize=(12, 8))
sns.scatterplot(x='price', y='points', data=country_avg_score_price, s=100, color='blue', edgecolor='black')

# Añadir etiquetas a los puntos
for i in range(len(country_avg_score_price)):
    plt.text(x=country_avg_score_price.iloc[i]['price'],
             y=country_avg_score_price.iloc[i]['points'],
             s=country_avg_score_price.index[i],
             fontweight='bold',
             ha='center',
             size=10)

plt.title('Precios y Puntuaciones Promedio por País', fontsize=16)
plt.xlabel('Precio Promedio', fontsize=14)
plt.ylabel('Puntuación Promedio', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.grid(True)
plt.tight_layout()
plt.show()

# Gráfico de precios y puntuaciones promedio por variedad
variety_avg_score_price = df_v8.groupby('variety').agg({'points': 'mean', 'price': 'mean'}).sort_values(by='price', ascending=False)

plt.figure(figsize=(12, 8))
sns.scatterplot(x='price', y='points', data=variety_avg_score_price, s=100, color='green', edgecolor='black')

# Añadir etiquetas a los puntos
for i in range(len(variety_avg_score_price)):
    plt.text(x=variety_avg_score_price.iloc[i]['price'],
             y=variety_avg_score_price.iloc[i]['points'],
             s=variety_avg_score_price.index[i],
             fontweight='bold',
             ha='center',
             size=10)

plt.title('Precios y Puntuaciones Promedio por Variedad de Uva', fontsize=16)
plt.xlabel('Precio Promedio', fontsize=14)
plt.ylabel('Puntuación Promedio', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.grid(True)
plt.tight_layout()
plt.show()


# Crear un segmento de mercado según el precio
bins = [0, 20, 50, 100, 200, 1000]
labels = ['Económico', 'Medio', 'Alto', 'Premium', 'Lujo']
df_v8['market_segment'] = pd.cut(df_v8['price'], bins=bins, labels=labels)

# Comparar las puntuaciones y precios promedio por segmento de mercado
segment_avg_score_price = df_v8.groupby('market_segment').agg({'points': 'mean', 'price': 'mean'}).sort_values(by='price', ascending=False)

# Imprimir el resultado
print(segment_avg_score_price)

# Crear el gráfico de dispersión
plt.figure(figsize=(10, 6))
sns.scatterplot(x='price', y='points', data=segment_avg_score_price, s=100, color='orange', edgecolor='black')

# Añadir etiquetas a los puntos
for i in range(len(segment_avg_score_price)):
    plt.text(x=segment_avg_score_price.iloc[i]['price'],
             y=segment_avg_score_price.iloc[i]['points'],
             s=segment_avg_score_price.index[i],  # Usar el índice de las categorías
             fontweight='bold',
             ha='center',
             size=10)

# Configurar título y etiquetas
plt.title('Precios y Puntuaciones Promedio por Segmento de Mercado', fontsize=16)
plt.xlabel('Precio Promedio', fontsize=14)
plt.ylabel('Puntuación Promedio', fontsize=14)
plt.grid(True)
plt.tight_layout()

# Mostrar el gráfico
plt.show()

# Relacionar con Precios, Bodegas, Países y Catadores
high_rated_price = df_v8.groupby('price')['points'].mean().sort_values(ascending=False)
high_rated_bodega = df_v8.groupby('winery')['points'].mean().sort_values(ascending=False).head(10)  # Solo top 10 bodegas
high_rated_country = df_v8.groupby('country')['points'].mean().sort_values(ascending=False).head(10)  # Solo top 10 países
high_rated_taster = df_v8.groupby('taster_name')['points'].mean().sort_values(ascending=False).head(10)  # Solo top 10 catadores

# Crear Visualizaciones de correlacion entre puntuaciones y precio

# Gráfico de Puntuaciones vs Precio
plt.figure(figsize=(12, 8))
sns.scatterplot(x='price', y='points', data=df_v8, s=100, color='purple', edgecolor='black')
plt.title('Vinos Mejor Calificados: Puntuación vs Precio', fontsize=16)
plt.xlabel('Precio', fontsize=14)
plt.ylabel('Puntuación', fontsize=14)
plt.grid(True)
plt.tight_layout()
plt.show()


# Mostrar solo el valor de la correlación
corr_data = df_v8[['price', 'points']]
corr_matrix = corr_data.corr()
print("Correlación entre Precio y Puntuación:", corr_matrix.iloc[0, 1])

# Heatmap con mejor formato
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', center=0, linewidths=0.5, fmt='.2f')
plt.title('Correlación entre Precio y Puntuación Promedio (Vinos Mejor Calificados)', fontsize=16)
plt.tight_layout()
plt.show()



# ===========================================
# ** 10.7 Distribución de puntuaciones por catador **
# ===========================================
print("\n 10.7 Distribución de puntuaciones por catador \n")

# Crear un gráfico de caja (boxplot) para comparar las puntuaciones de los catadores
plt.figure(figsize=(12, 6))
sns.boxplot(data=df_v8, x='taster_name', y='points', palette='Set2')

# Personalizar el gráfico
plt.title('Distribución de puntuaciones por catador')
plt.xlabel('Catador')
plt.ylabel('Puntuación')
plt.xticks(rotation=45, ha='right')

# Mostrar el gráfico
plt.tight_layout()
plt.show()

# Gráfico de puntuaciones promedio por catador (solo vinos con puntuaciones entre 80 y 100)
plt.figure(figsize=(14, 7))
high_rated_taster.plot(kind='bar', color='orange')
plt.title('Puntuaciones Promedio por Catador (Vinos Mejor Calificados)', fontsize=16)
plt.xlabel('Catador', fontsize=14)
plt.ylabel('Puntuación Promedio', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.ylim(80, 100)
plt.show()


# ===========================================
# ** 10.8 Analisis de palabras mas frecuentes en vinos altamente calificados y menos calificados **
# ===========================================
print("\n 10.8 Analisis de palabras mas frecuentes en vinos altamente calificados y menos calificados \n")


# Descargar las palabras de parada de NLTK
nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

# Añadir palabras irrelevantes específicas
irrelevant_words = stop_words.union({'wine', 'flavor'})

# Filtrar descripciones según calificaciones
high_rated = df_v8[df_v8['points'] >= 95]['description']
low_rated = df_v8[df_v8['points'] <= 85]['description']

# Función para procesar texto y contar palabras
def process_text(text_series):
    words = []
    for text in text_series:
        if pd.notnull(text):  # Verifica que no sea NaN
            # Convertir a minúsculas, eliminar puntuación y separar palabras
            text = text.lower().translate(str.maketrans('', '', string.punctuation))
            # Filtrar palabras irrelevantes
            words.extend([word for word in text.split() if word not in irrelevant_words])
    return Counter(words)

# Contar palabras en ambos grupos
high_rated_words = process_text(high_rated)
low_rated_words = process_text(low_rated)

# Obtener las 20 palabras más comunes
high_rated_top = high_rated_words.most_common(20)
low_rated_top = low_rated_words.most_common(20)

# Función para graficar palabras más frecuentes
def plot_top_words(word_counts, title):
    words, counts = zip(*word_counts)
    plt.figure(figsize=(10, 6))
    plt.bar(words, counts, color='skyblue')
    plt.title(title)
    plt.ylabel('Frecuencia')
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()

# Graficar palabras más comunes
plot_top_words(high_rated_top, 'Palabras más frecuentes en vinos altamente calificados')
plot_top_words(low_rated_top, 'Palabras más frecuentes en vinos menos calificados')

# Función para graficar nube de palabras
def plot_wordcloud(word_counts, title):
    wordcloud = WordCloud(width=800, height=400, background_color='white').generate_from_frequencies(dict(word_counts))
    plt.figure(figsize=(10, 6))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.title(title)
    plt.axis('off')
    plt.show()

# Graficar nubes de palabras
plot_wordcloud(high_rated_words, 'Nube de palabras: vinos altamente calificados')
plot_wordcloud(low_rated_words, 'Nube de palabras: vinos menos calificados')

# Contar cuántas veces cada varietal ha sido catado por cada catador
varietal_by_taster = df_v8.groupby(['taster_name', 'variety']).size().reset_index(name='count')


# ===========================================
# ** 10.9 varietal más catado por cada catador **
# ===========================================
print("\n 10.9 varietal más catado por cada catador \n")

# Obtener el varietal más catado por cada catador
top_varietal_per_taster = varietal_by_taster.loc[varietal_by_taster.groupby('taster_name')['count'].idxmax()]

# Crear gráfico de barras
plt.figure(figsize=(14, 7))
sns.barplot(x='taster_name', y='count', hue='variety', data=top_varietal_per_taster, palette='Set2')
plt.title('Varietal Más Catado por Cada Catador', fontsize=16)
plt.xlabel('Catador', fontsize=14)
plt.ylabel('Número de Catas', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# ===========================================
# ** 10.10 Paises y Provincias mas catados por cada catador **
# ===========================================
print("\n 10.10 Paises y Provincias mas catados por cada catador \n")

# Contar cuántas veces cada provincia y país ha sido catado por cada catador
province_by_taster = df_v8.groupby(['taster_name', 'province']).size().reset_index(name='count')
country_by_taster = df_v8.groupby(['taster_name', 'country']).size().reset_index(name='count')

# Obtener la provincia y el país más catados por cada catador
top_province_per_taster = province_by_taster.loc[province_by_taster.groupby('taster_name')['count'].idxmax()]
top_country_per_taster = country_by_taster.loc[country_by_taster.groupby('taster_name')['count'].idxmax()]

# Crear gráfico de barras para provincias
plt.figure(figsize=(14, 7))
sns.barplot(x='taster_name', y='count', hue='province', data=top_province_per_taster, palette='coolwarm')
plt.title('Provincia Más Catada por Cada Catador', fontsize=16)
plt.xlabel('Catador', fontsize=14)
plt.ylabel('Número de Catas', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Crear gráfico de barras para países
plt.figure(figsize=(14, 7))
sns.barplot(x='taster_name', y='count', hue='country', data=top_country_per_taster, palette='viridis')
plt.title('País Más Catado por Cada Catador', fontsize=16)
plt.xlabel('Catador', fontsize=14)
plt.ylabel('Número de Catas', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# ===========================================
# ** 10.11 Clusterizacion por KMeans **
# ===========================================
print("\n 10.11 Clusterizacion por KMeans \n")

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

# Seleccionar las columnas relevantes para la clusterización
features = df_v8[['price', 'points']]  # Puedes incluir más características si lo deseas

# Normalizar los datos (es importante para K-means)
scaler = StandardScaler()
features_scaled = scaler.fit_transform(features)

# Aplicar el modelo K-means
kmeans = KMeans(n_clusters=3, random_state=42)  # Puedes cambiar el número de clusters según tus necesidades
df_v8['cluster'] = kmeans.fit_predict(features_scaled)

# Mostrar los resultados
sns.scatterplot(x='price', y='points', hue='cluster', data=df_v8, palette='Set2')
plt.title('Clusterización de Vinos por Precio y Puntuación')
plt.show()

# Ver los valores promedio de las características para cada cluster
cluster_summary = df_v8.groupby('cluster')[['price', 'points']].mean()
print(cluster_summary)

# Boxplots para ver la distribución de las puntuaciones y precios por cluster
plt.figure(figsize=(14, 7))

# Distribución de puntuaciones por cluster
plt.subplot(1, 2, 1)
sns.boxplot(x='cluster', y='points', data=df_v8)
plt.title('Distribución de Puntuaciones por Cluster')

# Distribución de precios por cluster
plt.subplot(1, 2, 2)
sns.boxplot(x='cluster', y='price', data=df_v8)
plt.title('Distribución de Precios por Cluster')

plt.tight_layout()
plt.show()

# Visualización de los clusters usando un gráfico de dispersión
sns.scatterplot(x='price', y='points', hue='cluster', data=df_v8, palette='Set2')
plt.title('Distribución de Clusters: Precio vs Puntuación')
plt.show()


print("MUCHAS GRACIAS, ALUMNA CONSTANZA SCHMIT")